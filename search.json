[{"path":"https://joshuawiley.com/extraoperators/articles/logicals-vignette.html","id":"logical-comparisons","dir":"Articles","previous_headings":"","what":"Logical Comparisons","title":"Logical Operators","text":"section covers basic logical comparisons shows might done base R versus using extraoperators package. Many quite simple, defined later operators possible. First let’s define “data” numbers stored sample_numbers. Now can series simple logical comparisons return logical vector TRUE FALSE. Unfortunately, use < > custom operators, use substitutions: g = > l = < e = =. ge = <= etc. far real gain using extraoperators changes complex operations. want know values fall within range? fairly common task, saying valid ages must 0 100 years. Base R accomplishes chaining operations. extraoperators built range operators. Finally, extraoperators includes operator, %!%. next sections show examples operators augmented prefixes: ?, s .","code":"sample_numbers <- c(9, 1, 5, 3, 4, 10, 99) ## base R: greater than 3? sample_numbers > 3 #> [1]  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  ## base R: greater than or equal to 3? sample_numbers >= 3 #> [1]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  ## base R: less than 3? sample_numbers < 3 #> [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  ## base R: less than or equal to 3? sample_numbers <= 3 #> [1] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE ## extraoperators: greater than 3? sample_numbers %g% 3 #> [1]  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  ## extraoperators: greater than or equal to 3? sample_numbers %ge% 3 #> [1]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  ## extraoperators: less than 3? sample_numbers %l% 3 #> [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  ## extraoperators: less than or equal to 3? sample_numbers %le% 3 #> [1] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE ## base R: greater than 3 and less than 10? sample_numbers > 3 & sample_numbers < 10 #> [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  ## base R: greater than or equal to 3 and less than 10? sample_numbers >= 3 & sample_numbers < 10 #> [1]  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE  ## base R: greater than 3 and less than or equal to 10? sample_numbers > 3 & sample_numbers <= 10 #> [1]  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE  ## base R: greater than or equal to 3 and less than or equal to 10? sample_numbers >= 3 & sample_numbers <= 10 #> [1]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE ## extraoperators: greater than 3 and less than 10? sample_numbers %gl% c(3, 10) #> [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  ## extraoperators: greater than or equal to 3 and less than 10? sample_numbers %gel% c(3, 10) #> [1]  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE  ## extraoperators: greater than 3 and less than or equal to 10? sample_numbers %gle% c(3, 10) #> [1]  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE  ## extraoperators: greater than or equal to 3 and less than or equal to 10? sample_numbers %gele% c(3, 10) #> [1]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE ## base R: not in 3 or 10 !sample_numbers %in% c(3, 10) #> [1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  ## extraoperators: not in 3 or 10 sample_numbers %!in% c(3, 10) #> [1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE"},{"path":"https://joshuawiley.com/extraoperators/articles/logicals-vignette.html","id":"indices-which-values","dir":"Articles","previous_headings":"","what":"Indices (Which Values?)","title":"Logical Operators","text":"Sometimes want use logical comparison identify indices, use loop. extraoperators prefixing operators ? “”. can readily incorporated code processing.","code":"## base R: what are the indices that match 3 and 10? which(sample_numbers %in% c(3, 10)) #> [1] 4 6  ## extraoperators: what are the indices that match 3 and 10? sample_numbers %?in% c(3, 10) #> [1] 4 6  ## base R: what are the indices for numbers between 3 and 10? which(sample_numbers > 3 & sample_numbers < 10) #> [1] 1 3 5  ## extraoperators: what are the indices for numbers between 3 and 10? sample_numbers %?gl% c(3, 10) #> [1] 1 3 5"},{"path":"https://joshuawiley.com/extraoperators/articles/logicals-vignette.html","id":"subsetting","dir":"Articles","previous_headings":"","what":"Subsetting","title":"Logical Operators","text":"Another fairly common task selecting certain observations. example, might want calculate average numbers within plausible range (e.g., excluding outliers). extraoperators subsetting done adding s prefix. Subsetting can especially useful quick exploratory analyses. Graphs easily hard read extreme values. Subsetting makes fast “zoom ” specific range.","code":"## base R: subset to only numbers between 3 and 10 mean(subset(sample_numbers, sample_numbers > 3 & sample_numbers < 10)) #> [1] 6  ## or equivalently  mean(sample_numbers[sample_numbers > 3 & sample_numbers < 10]) #> [1] 6  ## extraoperators: subset to only numbers between 3 and 10 mean(sample_numbers %sgl% c(3, 10)) #> [1] 6"},{"path":"https://joshuawiley.com/extraoperators/articles/logicals-vignette.html","id":"all-or-none","dir":"Articles","previous_headings":"","what":"All (or None)","title":"Logical Operators","text":"Finally, might quality controls place data. example asserting ages 0 100. extraoperators done adding prefix . want know opposite, numbers 0 100, can negate whole operation. also expanded , subset, operators equals equals.","code":"## base R: are all numbers between 0 and 10? all(sample_numbers > 0 & sample_numbers < 10) #> [1] FALSE  ## extraoperators: are all numbers between 0 and 10? sample_numbers %agl% c(0, 10) #> [1] FALSE  ## extraoperators: are all numbers between 0 and 100? sample_numbers %agl% c(0, 100) #> [1] TRUE ## extraoperators: are NO numbers between 0 and 100? !sample_numbers %agl% c(0, 100) #> [1] FALSE  ## extraoperators: are NO numbers between 55 and 60? !sample_numbers %agl% c(55, 60) #> [1] TRUE ## extraoperators: are all values equal? sample_numbers %a==% sample_numbers #> [1] TRUE  ## extraoperators: are all values NOT equal? c(1, 3, 5) %a!=% c(5, 1, 3) #> [1] TRUE"},{"path":"https://joshuawiley.com/extraoperators/articles/logicals-vignette.html","id":"chaining","dir":"Articles","previous_headings":"","what":"Chaining","title":"Logical Operators","text":"language, fairly natural make statement like : “study, age 18 65 missing.” R, usual implementation equivalent : “study, age greater 18 age less 65 age missing.” extraoperators tries facilitate something closer cleaner original statement using chaining operator, %c%. chaining operator chains set operations right hand side argument left hand side passed . accomplish , right hand side must quoted. right hand side chaining operator character string parsed, possible special things . .na, !.na, .nan, !.nan special characters require value work correctly. shown, parentheses also work, allows fine grained control exactly intended. example expect adults study, refused report age coded -9 people failed complete questionnaire missing. operators, prefixes , subset, .","code":"age <- c(19, 30, 90, 50, NA, 45) age %c% \"(> 18 & < 65) & !is.na\" #> [1]  TRUE  TRUE FALSE  TRUE FALSE  TRUE age <- c(19, 30, 90, 50, NA, 16, -9) age %c% \"(> 18 | == -9) & !is.na\" #> [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE age %ac% \"(> 18 | == -9) & !is.na\" #> [1] FALSE  age %ac% \"> -Inf\" #> [1] NA age %ac% \"> -Inf & !is.na\" #> [1] FALSE age %ac% \"> -Inf | is.na\" #> [1] TRUE  age %sc% \"(> 18 | == -9) & !is.na\" #> [1] 19 30 90 50 -9  age %?c% \"(> 18 | == -9) & !is.na\" #> [1] 1 2 3 4 7"},{"path":"https://joshuawiley.com/extraoperators/articles/logicals-vignette.html","id":"interval-notation-operator","dir":"Articles","previous_headings":"","what":"Interval Notation Operator","title":"Logical Operators","text":"math, interval notation often used. example, might write: \\(x \\(1, 5) \\cup [6, \\infty)\\) indicate x intervals 1 5 (including 1 5) 6 positive infinity, including 6 positive infinity. interval notation operator, %e% let’s use fairly similar language R. “|” union operator “&” intersect operator. Variables allowed functions parsed.","code":"c(1, 2, 6, 300) %e% \"(1, 5) | [6, Inf)\" #> [1] FALSE  TRUE  TRUE  TRUE  ## this is OK x <- max(mtcars$mpg) c(1, 2, 6, 300) %e% \"(1, 5) | [6, x)\" #> [1] FALSE  TRUE  TRUE FALSE  ## ## this would NOT be OK ## c(1, 2, 6, 300) %e% \"(1, 5) | [6, max(mtcars$mpg))\""},{"path":"https://joshuawiley.com/extraoperators/articles/logicals-vignette.html","id":"regular-expressions","dir":"Articles","previous_headings":"","what":"Regular Expressions","title":"Logical Operators","text":"Sometimes want pattern match. example, might want find variable names match certain pattern. %grepl% operator can help , built offR'sgrepl` function. example use case practice might find variables items scale calculate scale score. Another example load larger dataset someone want check whether variable names including spaces. want check space, regular expression captured “\\s”, contained variable name. space. returns TRUE indicating variable names space . example fails. least one variable name space. follow finding variable(s). fed back data owners change, desired. Lastly, although written separate codes, used interactively, one might start test fails change ! s find variables. intention just slightly ease speed process.","code":"## sample dataset data <- data.frame(   ID = c(1, 2, 3),   cesd_1 = c(4, 5, 6),   cesd_2 = c(7, 8, 9),   cesd_total = c(11, 13, 15) )  ## find all variables that start with \"cesd\" names(data)[grepl(\"^cesd\", names(data))] #> [1] \"cesd_1\"     \"cesd_2\"     \"cesd_total\"  ## or equivalently using grep() with right options grep(\"^cesd\", names(data), value = TRUE) #> [1] \"cesd_1\"     \"cesd_2\"     \"cesd_total\"  ## here is the operator version names(data) %sgrepl% \"^cesd\" #> [1] \"cesd_1\"     \"cesd_2\"     \"cesd_total\"  ## the operator opens up all standard variations names(data) %?grepl% \"^cesd\" ## indices #> [1] 2 3 4 names(data) %s!grepl% \"^cesd\" ## subset names not in pattern #> [1] \"ID\" names(data) %agrepl% \"^cesd\" ## do all match the pattern? #> [1] FALSE set.seed(123) # Set seed for reproducibility data <- data.frame(matrix(sample(0:4, 100, replace = TRUE), ncol = 10)) names(data) <- paste0(\"cesd_\", 1:10) data <- cbind(ID = 1:10, data)  ## find all variables that start with \"cesd\" and end with a number ## use these to sum all the items for the scale score data$cesd_total <- rowSums(data[, names(data) %sgrepl% \"^cesd.*[0-9]$\"])  summary(data$cesd_total) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>    12.0    18.0    19.0    19.3    20.5    25.0 names(mtcars) %a!grepl% \"\\\\s\" #> [1] TRUE data <- data.frame(   a = 1:4,   `b c` = 5:8, check.names = FALSE )  names(data) %a!grepl% \"\\\\s\" # this fails #> [1] FALSE  # which variables have spaces? names(data) %sgrepl% \"\\\\s\"  #> [1] \"b c\""},{"path":"https://joshuawiley.com/extraoperators/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Joshua F. Wiley. Author, maintainer.","code":""},{"path":"https://joshuawiley.com/extraoperators/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wiley J (2023). extraoperators: Extra Binary Relational Logical Operators. R package version 0.3.0, https://github.com/JWiley/extraoperators, https://joshuawiley.com/extraoperators/.","code":"@Manual{,   title = {extraoperators: Extra Binary Relational and Logical Operators},   author = {Joshua F. Wiley},   year = {2023},   note = {R package version 0.3.0, https://github.com/JWiley/extraoperators},   url = {https://joshuawiley.com/extraoperators/}, }"},{"path":"https://joshuawiley.com/extraoperators/index.html","id":"extraoperators","dir":"","previous_headings":"","what":"extraoperators","title":"extraoperators","text":"R package operators help speed everyday tasks.","code":""},{"path":"https://joshuawiley.com/extraoperators/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"extraoperators","text":"get latest development version, use: Otherwise get CRAN use:","code":"#install.packages(\"devtools\") devtools::install_github(\"JWiley/extraoperators\") install.packages(\"extraoperators\")"},{"path":"https://joshuawiley.com/extraoperators/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"extraoperators","text":"table summarizes package provides. Fundamentally provides expands 14 different logical operators, can accessed return logical vector, also prefixed ? () return indices TRUE prefixed s (subset) return values TRUE prefixed () return single logical value, true? entire logical comparison can prefixed ! generate NONE evaluation. Using operators, can accomplish many different tasks just remembering additional prefixes: ? (), () s subset(). simple, can save quite keystrokes make various logical comparisons less convoluted.","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/dot-set1.html","id":null,"dir":"Reference","previous_headings":"","what":"Process Sets — .set1","title":"Process Sets — .set1","text":"internal function intended used directly. processes small sets.","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/dot-set1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process Sets — .set1","text":"","code":".set1(x, envir)"},{"path":"https://joshuawiley.com/extraoperators/reference/dot-set1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process Sets — .set1","text":"x character string envir environment evaluate values","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/dot-set1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process Sets — .set1","text":"data frame processed set","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/dot-set1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process Sets — .set1","text":"","code":"## ## below is an example that should generate an (informative) error ## extraoperators:::.set1(\"(-Inf,x)\", envir = environment())  z <- max(mtcars$mpg) extraoperators:::.set1(\"(-Inf,z)\", envir = environment()) #>   Op1 Val1 Con1 Op2 Val2 #> 1   > -Inf    &   < 33.9  extraoperators:::.set1(\"(-Inf,30)\", envir = environment()) #>   Op1 Val1 Con1 Op2 Val2 #> 1   > -Inf    &   <   30  ## clean up rm(z)"},{"path":"https://joshuawiley.com/extraoperators/reference/grapes-c-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Chain Operator — %c%","title":"Chain Operator — %c%","text":"operator allows operators right hand side chained together. intended use case single object want perform several operations. example, testing whether variable 1 5 equals special number 9, might used indicate someone responded question (.e., missing per se) preferred answer know answer.","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/grapes-c-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chain Operator — %c%","text":"","code":"e1 %c% e2"},{"path":"https://joshuawiley.com/extraoperators/reference/grapes-c-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chain Operator — %c%","text":"e1 values operated , left hand side e2 character string (MUST quoted) containing operators values apply `e1`. Note character string, operators can chained together using either `|` `&`. Parentheses also supported work expected. See examples information function used.","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/grapes-c-grapes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chain Operator — %c%","text":"logical vector","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/grapes-c-grapes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chain Operator — %c%","text":"` `.na`, `!.na`, `.nan`, `!.nan`. need values supplied work expected add logical assessments chain operators.","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/grapes-c-grapes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chain Operator — %c%","text":"","code":"## define a variable sample_data <- c(1, 3, 9, 5, NA, -9)  ## suppose that we expect that values should fall in [1, 10] ## unless they are special character, -9 used for unknown / refused sample_data %c% \"( >= 1 & <= 10 ) | == -9\" #> [1] TRUE TRUE TRUE TRUE   NA TRUE  ## we might expect some missing values and be OK as long as ## above conditions are met or values are missing sample_data %c% \"( >= 1 & <= 10 ) | == -9 | is.na\" #> [1] TRUE TRUE TRUE TRUE TRUE TRUE  ## equally we might be expecting NO missing values ## and want missing values to come up as FALSE sample_data %c% \"(( >= 1 & <= 10 ) | == -9) & !is.na\" #> [1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  c(1, 3, 9, 5, NA, -9) %c% \"is.na & (( >= 1 & <= 10 ) | == -9)\" #> [1] FALSE FALSE FALSE FALSE    NA FALSE  ## clean up rm(sample_data)"},{"path":"https://joshuawiley.com/extraoperators/reference/grapes-e-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Element In Set Operator — %e%","title":"Element In Set Operator — %e%","text":"operator allows use set notation style definitions","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/grapes-e-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Element In Set Operator — %e%","text":"","code":"e1 %e% e2"},{"path":"https://joshuawiley.com/extraoperators/reference/grapes-e-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Element In Set Operator — %e%","text":"e1 values operated , left hand side e2 character string containing set notation style defined ranges real number line. Separate sets “&” “|” operator .","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/grapes-e-grapes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Element In Set Operator — %e%","text":"logical vector","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/grapes-e-grapes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Element In Set Operator — %e%","text":"","code":"c(-1, 0, 1, 9, 10, 16, 17, 20) %e% \"(-Inf, 0) | [1, 9) | [10, 16] | (17, Inf]\" #> [1]  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE table(mtcars$mpg %e% \"(0, 15.5) | [22.8, 40)\") #>  #> FALSE  TRUE  #>    15    17  table(mtcars$mpg %e% \"(0, 15) | [16, 18] | [30, 50)\") #>  #> FALSE  TRUE  #>    20    12  c(-1, 0, 1) %e% \"(-Inf, Inf) & [0, 0] | [1, 1]\" #> [1] FALSE  TRUE  TRUE  z <- max(mtcars$mpg) table(mtcars$mpg %e% \"(-Inf, z)\") #>  #> FALSE  TRUE  #>     1    31   ## clean up rm(z)"},{"path":"https://joshuawiley.com/extraoperators/reference/logicalall.html","id":null,"dir":"Reference","previous_headings":"","what":"Several ways to evaluate whether all values meet logical conditions including logical range comparison helpers — logical all","title":"Several ways to evaluate whether all values meet logical conditions including logical range comparison helpers — logical all","text":"Several ways evaluate whether values meet logical conditions including logical range comparison helpers","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/logicalall.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Several ways to evaluate whether all values meet logical conditions including logical range comparison helpers — logical all","text":"","code":"e1 %agele% e2  e1 %agel% e2  e1 %agle% e2  e1 %agl% e2  e1 %age% e2  e1 %ag% e2  e1 %ale% e2  e1 %al% e2  e1 %ain% e2  e1 %a!in% e2  e1 %anin% e2  e1 %a==% e2  e1 %a!=% e2  e1 %ac% e2  e1 %ae% e2  e1 %agrepl% e2  e1 %a!grepl% e2"},{"path":"https://joshuawiley.com/extraoperators/reference/logicalall.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Several ways to evaluate whether all values meet logical conditions including logical range comparison helpers — logical all","text":"e1 number vector evaluated e2 vector one two numbers used denote limits logical comparison.","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/logicalall.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Several ways to evaluate whether all values meet logical conditions including logical range comparison helpers — logical all","text":"logical value whether e1 meet logical conditions.","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/logicalall.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Several ways to evaluate whether all values meet logical conditions including logical range comparison helpers — logical all","text":"","code":"1:5 %agele% c(2, 4) #> [1] FALSE 1:5 %agele% c(4, 2) # order does not matter uses min / max #> [1] FALSE  1:5 %agel% c(2, 4) #> [1] FALSE 1:5 %agel% c(4, 2) # order does not matter uses min / max #> [1] FALSE  1:5 %agle% c(2, 4) #> [1] FALSE 1:5 %agle% c(4, 2) # order does not matter uses min / max #> [1] FALSE  1:5 %agl% c(2, 4) #> [1] FALSE 1:5 %agl% c(4, 2) # order does not matter uses min / max #> [1] FALSE  1:5 %age% 2 #> [1] FALSE 1:5 %age% 4 #> [1] FALSE  1:5 %ag% 2 #> [1] FALSE 1:5 %ag% 4 #> [1] FALSE  1:5 %ale% 2 #> [1] FALSE 1:5 %ale% 4 #> [1] FALSE  1:5 %al% 2 #> [1] FALSE 1:5 %al% 4 #> [1] FALSE  1:5 %ain% c(2, 99) #> [1] FALSE c(\"jack\", \"jill\", \"john\", \"jane\") %ain% c(\"jill\", \"jane\", \"bill\") #> [1] FALSE  1:5 %a!in% c(2, 99) #> [1] FALSE c(\"jack\", \"jill\", \"john\", \"jane\") %a!in% c(\"jill\", \"jane\", \"bill\") #> [1] FALSE  1:5 %a==% 1:5 #> [1] TRUE 1:5 %a==% 5:1 #> [1] FALSE  1:5 %a!=% 1:5 #> [1] FALSE 1:5 %a!=% 5:1 #> [1] FALSE 1:5 %a!=% c(5, 4, 1, 3, 2) #> [1] TRUE ## define a variable sample_data <- c(1, 3, 9, 5, NA, -9)  ## suppose that we expect that values should fall in [1, 10] ## unless they are special character, -9 used for unknown / refused sample_data %ac% \"( >= 1 & <= 10 ) | == -9\" #> [1] NA  ## we might expect some missing values and be OK as long as ## above conditions are met or values are missing sample_data %ac% \"( >= 1 & <= 10 ) | == -9 | is.na\" #> [1] TRUE  ## equally we might be expecting NO missing values ## and want missing values to come up as FALSE sample_data %ac% \"(( >= 1 & <= 10 ) | == -9) & !is.na\" #> [1] FALSE  ## clean up rm(sample_data) ## define a variable sample_data <- c(1, 3, 9, 5, -9)  sample_data %ae% \"(-8, 1] | [2, 9)\" #> [1] FALSE sample_data %ae% \"(-Inf, Inf)\" #> [1] TRUE  ## clean up rm(sample_data)  c(\"jack\", \"jane\", \"ajay\") %agrepl% \"ja\" #> [1] TRUE c(\"jack\", \"jill\", \"john\", \"jane\", \"sill\", \"ajay\") %agrepl% \"^ja\" #> [1] FALSE  c(\"jack\", \"jane\", \"ajay\") %a!grepl% \"ja\" #> [1] FALSE c(\"jack\", \"jill\", \"john\", \"jane\", \"sill\", \"ajay\") %a!grepl% \"^ja\" #> [1] FALSE c(\"jack\", \"jill\", \"john\", \"jane\", \"sill\", \"ajay\") %a!grepl% \"ja$\" #> [1] TRUE"},{"path":"https://joshuawiley.com/extraoperators/reference/logicals.html","id":null,"dir":"Reference","previous_headings":"","what":"Several logical range comparison helpers — logicals","title":"Several logical range comparison helpers — logicals","text":"Several logical range comparison helpers","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/logicals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Several logical range comparison helpers — logicals","text":"","code":"e1 %gele% e2  e1 %gel% e2  e1 %gle% e2  e1 %gl% e2  e1 %g% e2  e1 %ge% e2  e1 %l% e2  e1 %le% e2  e1 %!in% e2  e1 %nin% e2  e1 %flipIn% e2  e1 %grepl% e2  e1 %!grepl% e2"},{"path":"https://joshuawiley.com/extraoperators/reference/logicals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Several logical range comparison helpers — logicals","text":"e1 number vector evaluated e2 vector one two numbers used denote limits logical comparison.","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/logicals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Several logical range comparison helpers — logicals","text":"logical vector length e1.","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/logicals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Several logical range comparison helpers — logicals","text":"","code":"1:5 %gele% c(2, 4) #> [1] FALSE  TRUE  TRUE  TRUE FALSE 1:5 %gele% c(4, 2) # order does not matter uses min / max #> [1] FALSE  TRUE  TRUE  TRUE FALSE  1:5 %gel% c(2, 4) #> [1] FALSE  TRUE  TRUE FALSE FALSE 1:5 %gel% c(4, 2) # order does not matter uses min / max #> [1] FALSE  TRUE  TRUE FALSE FALSE  1:5 %gle% c(2, 4) #> [1] FALSE FALSE  TRUE  TRUE FALSE 1:5 %gle% c(4, 2) # order does not matter uses min / max #> [1] FALSE FALSE  TRUE  TRUE FALSE  1:5 %gl% c(2, 4) #> [1] FALSE FALSE  TRUE FALSE FALSE 1:5 %gl% c(4, 2) # order does not matter uses min / max #> [1] FALSE FALSE  TRUE FALSE FALSE  1:5 %g% c(2) #> [1] FALSE FALSE  TRUE  TRUE  TRUE  1:5 %ge% c(2) #> [1] FALSE  TRUE  TRUE  TRUE  TRUE  1:5 %l% c(2) #> [1]  TRUE FALSE FALSE FALSE FALSE  1:5 %le% c(2) #> [1]  TRUE  TRUE FALSE FALSE FALSE  1:5 %!in% c(2, 99) #> [1]  TRUE FALSE  TRUE  TRUE  TRUE c(\"jack\", \"jill\", \"john\", \"jane\") %!in% c(\"jill\", \"jane\", \"bill\") #> [1]  TRUE FALSE  TRUE FALSE  c(\"jack\", \"jill\", \"john\", \"jane\", \"sill\", \"ajay\") %grepl% \"ja\" #> [1]  TRUE FALSE FALSE  TRUE FALSE  TRUE c(\"jack\", \"jill\", \"john\", \"jane\", \"sill\", \"ajay\") %grepl% \"^ja\" #> [1]  TRUE FALSE FALSE  TRUE FALSE FALSE  c(\"jack\", \"jill\", \"john\", \"jane\", \"sill\", \"ajay\") %!grepl% \"ja\" #> [1] FALSE  TRUE  TRUE FALSE  TRUE FALSE c(\"jack\", \"jill\", \"john\", \"jane\", \"sill\", \"ajay\") %!grepl% \"^ja\" #> [1] FALSE  TRUE  TRUE FALSE  TRUE  TRUE"},{"path":"https://joshuawiley.com/extraoperators/reference/logicalwhich.html","id":null,"dir":"Reference","previous_headings":"","what":"Several ways to return an index based on logical range comparison helpers — logical indexes (which)","title":"Several ways to return an index based on logical range comparison helpers — logical indexes (which)","text":"Several ways return index based logical range comparison helpers","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/logicalwhich.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Several ways to return an index based on logical range comparison helpers — logical indexes (which)","text":"","code":"e1 %?gele% e2  e1 %?gel% e2  e1 %?gle% e2  e1 %?gl% e2  e1 %?ge% e2  e1 %?g% e2  e1 %?le% e2  e1 %?l% e2  e1 %?in% e2  e1 %?!in% e2  e1 %?nin% e2  e1 %?==% e2  e1 %?!=% e2  e1 %?c% e2  e1 %?e% e2  e1 %?grepl% e2  e1 %?!grepl% e2"},{"path":"https://joshuawiley.com/extraoperators/reference/logicalwhich.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Several ways to return an index based on logical range comparison helpers — logical indexes (which)","text":"e1 number vector evaluated indices returned e2 vector one two numbers used denote limits logical comparison.","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/logicalwhich.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Several ways to return an index based on logical range comparison helpers — logical indexes (which)","text":"vector indices identifying values e1 meet logical conditions.","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/logicalwhich.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Several ways to return an index based on logical range comparison helpers — logical indexes (which)","text":"","code":"1:5 %?gele% c(2, 4) #> [1] 2 3 4 1:5 %?gele% c(4, 2) # order does not matter uses min / max #> [1] 2 3 4  1:5 %?gel% c(2, 4) #> [1] 2 3 1:5 %?gel% c(4, 2) # order does not matter uses min / max #> [1] 2 3  1:5 %?gle% c(2, 4) #> [1] 3 4 1:5 %?gle% c(4, 2) # order does not matter uses min / max #> [1] 3 4  1:5 %?gl% c(2, 4) #> [1] 3 1:5 %?gl% c(4, 2) # order does not matter uses min / max #> [1] 3  1:5 %?ge% 2 #> [1] 2 3 4 5 1:5 %?ge% 4 #> [1] 4 5  1:5 %?g% 2 #> [1] 3 4 5 1:5 %?g% 4 #> [1] 5  1:5 %?le% 2 #> [1] 1 2 1:5 %?le% 4 #> [1] 1 2 3 4  1:5 %?l% 2 #> [1] 1 1:5 %?l% 4 #> [1] 1 2 3  1:5 %?in% c(2, 99) #> [1] 2 c(\"jack\", \"jill\", \"john\", \"jane\") %?in% c(\"jill\", \"jane\", \"bill\") #> [1] 2 4  1:5 %?!in% c(2, 99) #> [1] 1 3 4 5 c(\"jack\", \"jill\", \"john\", \"jane\") %?!in% c(\"jill\", \"jane\", \"bill\") #> [1] 1 3  1:5 %?nin% c(2, 99) #> [1] 1 3 4 5 c(\"jack\", \"jill\", \"john\", \"jane\") %snin% c(\"jill\", \"jane\", \"bill\") #> [1] \"jack\" \"john\"  11:15 %?==% c(11, 1, 13, 15, 15) #> [1] 1 3 5  11:15 %?!=% c(11, 1, 13, 15, 15) #> [1] 2 4 ## define a variable sample_data <- c(1, 3, 9, 5, NA, -9)  ## suppose that we expect that values should fall in [1, 10] ## unless they are special character, -9 used for unknown / refused sample_data %?c% \"( >= 1 & <= 10 ) | == -9\" #> [1] 1 2 3 4 6  ## we might expect some missing values and be OK as long as ## above conditions are met or values are missing sample_data %?c% \"( >= 1 & <= 10 ) | == -9 | is.na\" #> [1] 1 2 3 4 5 6  ## equally we might be expecting NO missing values ## and want missing values to come up as FALSE sample_data %?c% \"(( >= 1 & <= 10 ) | == -9) & !is.na\" #> [1] 1 2 3 4 6  ## clean up rm(sample_data) ## define a variable sample_data <- c(1, 3, 9, 5, -9)  sample_data %?e% \"(-8, 1] | [2, 9)\" #> [1] 1 2 4  ## clean up rm(sample_data)  c(\"jack\", \"jill\", \"john\", \"jane\", \"sill\", \"ajay\") %?grepl% \"ja\" #> [1] 1 4 6 c(\"jack\", \"jill\", \"john\", \"jane\", \"sill\", \"ajay\") %?grepl% \"^ja\" #> [1] 1 4  c(\"jack\", \"jill\", \"john\", \"jane\", \"sill\", \"ajay\") %?!grepl% \"ja\" #> [1] 2 3 5 c(\"jack\", \"jill\", \"john\", \"jane\", \"sill\", \"ajay\") %?!grepl% \"^ja\" #> [1] 2 3 5 6"},{"path":"https://joshuawiley.com/extraoperators/reference/subsetting.html","id":null,"dir":"Reference","previous_headings":"","what":"Several ways to subset based on logical range comparison helpers — subsetting","title":"Several ways to subset based on logical range comparison helpers — subsetting","text":"Several ways subset based logical range comparison helpers","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/subsetting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Several ways to subset based on logical range comparison helpers — subsetting","text":"","code":"e1 %sgele% e2  e1 %sgel% e2  e1 %sgle% e2  e1 %sgl% e2  e1 %sge% e2  e1 %sg% e2  e1 %sle% e2  e1 %sl% e2  e1 %sin% e2  e1 %s!in% e2  e1 %snin% e2  e1 %s==% e2  e1 %s!=% e2  e1 %sc% e2  e1 %se% e2  e1 %sgrepl% e2  e1 %s!grepl% e2"},{"path":"https://joshuawiley.com/extraoperators/reference/subsetting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Several ways to subset based on logical range comparison helpers — subsetting","text":"e1 number vector evaluated subset e2 vector one two numbers used denote limits logical comparison.","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/subsetting.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Several ways to subset based on logical range comparison helpers — subsetting","text":"subset e1 meets logical conditions.","code":""},{"path":"https://joshuawiley.com/extraoperators/reference/subsetting.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Several ways to subset based on logical range comparison helpers — subsetting","text":"","code":"1:5 %sgele% c(2, 4) #> [1] 2 3 4 1:5 %sgele% c(4, 2) # order does not matter uses min / max #> [1] 2 3 4  1:5 %sgel% c(2, 4) #> [1] 2 3 1:5 %sgel% c(4, 2) # order does not matter uses min / max #> [1] 2 3  1:5 %sgle% c(2, 4) #> [1] 3 4 1:5 %sgle% c(4, 2) # order does not matter uses min / max #> [1] 3 4  1:5 %sgl% c(2, 4) #> [1] 3 1:5 %sgl% c(4, 2) # order does not matter uses min / max #> [1] 3  1:5 %sge% 2 #> [1] 2 3 4 5 1:5 %sge% 4 #> [1] 4 5  1:5 %sg% 2 #> [1] 3 4 5 1:5 %sg% 4 #> [1] 5  1:5 %sle% 2 #> [1] 1 2 1:5 %sle% 4 #> [1] 1 2 3 4  1:5 %sl% 2 #> [1] 1 1:5 %sl% 4 #> [1] 1 2 3  1:5 %sin% c(2, 99) #> [1] 2 c(\"jack\", \"jill\", \"john\", \"jane\") %sin% c(\"jill\", \"jane\", \"bill\") #> [1] \"jill\" \"jane\"  1:5 %s!in% c(2, 99) #> [1] 1 3 4 5 c(\"jack\", \"jill\", \"john\", \"jane\") %s!in% c(\"jill\", \"jane\", \"bill\") #> [1] \"jack\" \"john\"  1:5 %s==% 1:5 #> [1] 1 2 3 4 5 1:5 %s==% c(1:4, 1) #> [1] 1 2 3 4  1:5 %s!=% 1:5 #> integer(0) 1:5 %s!=% c(1:4, 1) #> [1] 5 ## define a variable sample_data <- c(1, 3, 9, 5, NA, -9)  ## suppose that we expect that values should fall in [1, 10] ## unless they are special character, -9 used for unknown / refused sample_data %sc% \"( >= 1 & <= 10 ) | == -9\" #> [1]  1  3  9  5 NA -9  ## we might expect some missing values and be OK as long as ## above conditions are met or values are missing sample_data %sc% \"( >= 1 & <= 10 ) | == -9 | is.na\" #> [1]  1  3  9  5 NA -9  ## equally we might be expecting NO missing values ## and want missing values to come up as FALSE sample_data %sc% \"(( >= 1 & <= 10 ) | == -9) & !is.na\" #> [1]  1  3  9  5 -9  ## clean up rm(sample_data) ## define a variable sample_data <- c(1, 3, 9, 5, -9)  sample_data %se% \"(-8, 1] | [2, 9)\" #> [1] 1 3 5  ## clean up rm(sample_data)  c(\"jack\", \"jill\", \"john\", \"jane\", \"sill\", \"ajay\") %sgrepl% \"ja\" #> [1] \"jack\" \"jane\" \"ajay\" c(\"jack\", \"jill\", \"john\", \"jane\", \"sill\", \"ajay\") %sgrepl% \"^ja\" #> [1] \"jack\" \"jane\"  c(\"jack\", \"jill\", \"john\", \"jane\", \"sill\", \"ajay\") %s!grepl% \"ja\" #> [1] \"jill\" \"john\" \"sill\" c(\"jack\", \"jill\", \"john\", \"jane\", \"sill\", \"ajay\") %s!grepl% \"^ja\" #> [1] \"jill\" \"john\" \"sill\" \"ajay\""},{"path":"https://joshuawiley.com/extraoperators/news/index.html","id":"extraoperators-030","dir":"Changelog","previous_headings":"","what":"extraoperators 0.3.0","title":"extraoperators 0.3.0","text":"introduced new %grepl% related operators regular expression based matching, indexing, subsetting","code":""},{"path":"https://joshuawiley.com/extraoperators/news/index.html","id":"extraoperators-020","dir":"Changelog","previous_headings":"","what":"extraoperators 0.2.0","title":"extraoperators 0.2.0","text":"Minor change use testthat 3e. Moved github actions CI testing Version bump now reasonably stable.","code":""},{"path":"https://joshuawiley.com/extraoperators/news/index.html","id":"extraoperators-011","dir":"Changelog","previous_headings":"","what":"extraoperators 0.1.1","title":"extraoperators 0.1.1","text":"CRAN release: 2019-11-04 BUGFIX: resolved bug %c% multiple parentheses used. Additional tests added help check scenarios.","code":""},{"path":"https://joshuawiley.com/extraoperators/news/index.html","id":"extraoperators-010","dir":"Changelog","previous_headings":"","what":"extraoperators 0.1.0","title":"extraoperators 0.1.0","text":"Initial release","code":""}]
